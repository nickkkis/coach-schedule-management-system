Index: api_csms/csms/views.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from django.db.models import Count\r\nfrom rest_framework.views import APIView\r\nfrom rest_framework.response import Response\r\nfrom django.http.response import JsonResponse\r\nfrom .models import Training, Enrollments, Activity\r\nfrom .serializers import TrainingSerializer, EnrollmentsSerializer, ActivityLogSerializer, ActivitySerializer\r\nfrom rest_framework import viewsets, status, generics\r\nfrom rest_framework.decorators import action\r\nfrom rest_framework.response import Response\r\nfrom . import models\r\nfrom django.utils import timezone\r\nfrom django_filters.rest_framework import DjangoFilterBackend\r\n# from django.contrib.auth.models import User\r\nfrom .serializers import TrainingSerializer\r\nfrom rest_framework import viewsets, status\r\nfrom rest_framework.decorators import action\r\nfrom .models import User_log, User, Location, ActivityLog, Activity\r\nfrom .serializers import UserLogSerializer, UserSerializer, LocationSerializer\r\nfrom rest_framework.authtoken.models import Token\r\nfrom rest_framework.permissions import AllowAny, IsAdminUser, IsAuthenticated\r\nfrom rest_framework.authtoken.views import ObtainAuthToken\r\nfrom django.shortcuts import get_object_or_404\r\nfrom datetime import datetime\r\nfrom django.utils import timezone\r\nimport collections\r\nfrom datetime import datetime, timedelta\r\nimport pytz\r\nfrom django.db.models import Count\r\nfrom collections import defaultdict\r\nimport json\r\n\r\n\r\n# Create your views here.\r\n\r\nclass ClassSchedulesListView(APIView):\r\n    permission_classes = [IsAdminUser]\r\n\r\n    def post(self, request):\r\n        data = request.data\r\n        serializer = TrainingSerializer(data=data)\r\n\r\n        if serializer.is_valid():\r\n            start_time = serializer.validated_data['start_time']\r\n            end_time = serializer.validated_data['end_time']\r\n            current_time = timezone.now()\r\n            if end_time < start_time:\r\n                return Response({'error': 'End date/time cannot be less than Start date/time.'},\r\n                                status=status.HTTP_400_BAD_REQUEST)\r\n            elif start_time < current_time or end_time < current_time:\r\n                return Response({'error': 'Start or End date/time cannot be less than current system time.'},\r\n                                status=status.HTTP_400_BAD_REQUEST)\r\n            else:\r\n                serializer.save()\r\n                return Response(serializer.data, status=status.HTTP_201_CREATED)\r\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\r\n\r\n\r\nclass UserLogViewSet(viewsets.ModelViewSet):\r\n    queryset = User_log.objects.all()\r\n    serializer_class = UserLogSerializer\r\n    permission_classes = [IsAdminUser]\r\n\r\n    def checkin(self, request):\r\n        username = request.data.get('username')\r\n        location_id = request.data.get('location_id')  # Get location from request data\r\n\r\n        # Filter user_log entries by both username and location\r\n        try:\r\n            latest_log_entry = User_log.objects.filter(username=username, location_id=location_id).latest(\r\n                'checkin_time')\r\n            if latest_log_entry.checkout_time is None:\r\n                return Response({'error': 'User has already checked in at this location and not yet checked out.'},\r\n                                status=status.HTTP_400_BAD_REQUEST)\r\n        except User_log.DoesNotExist:\r\n            pass  # Allow check-in if no previous entry is found for the location\r\n\r\n        current_time = datetime.utcnow()\r\n        formatted_time = current_time.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'\r\n        request.data['checkin_time'] = formatted_time\r\n\r\n        serializer = UserLogSerializer(data=request.data)\r\n        if serializer.is_valid():\r\n            serializer.save()\r\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\r\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\r\n\r\n    @action(detail=False, methods=['put'])\r\n    def checkout(self, request):\r\n        username = request.data.get('username')\r\n        location_id = request.data.get('location_id')\r\n        current_time = datetime.utcnow()\r\n        checkout_time = current_time.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'\r\n        request.data['checkout_time'] = checkout_time\r\n        try:\r\n            log_entry = User_log.objects.filter(username=username, location_id=location_id).latest('checkin_time')\r\n            if log_entry.checkout_time:\r\n                return Response({'error': 'User has already checked out.'}, status=status.HTTP_400_BAD_REQUEST)\r\n            else:\r\n                log_entry.checkout_time = checkout_time\r\n                log_entry.save()\r\n                serializer = UserLogSerializer(log_entry)\r\n                return Response(serializer.data)\r\n        except User_log.DoesNotExist:\r\n            return Response({'error': 'User has no check-in entry.'}, status=status.HTTP_400_BAD_REQUEST)\r\n\r\n\r\nclass SignupSet(viewsets.ModelViewSet):\r\n    queryset = User.objects.all()\r\n    serializer_class = UserSerializer\r\n    permission_classes = [IsAdminUser]\r\n\r\n    @action(detail=False, methods=['post'])\r\n    def signup(self, request):\r\n        try:\r\n            serializer = UserSerializer(data=request.data)\r\n            if serializer.is_valid():\r\n                serializer.save()\r\n                return Response(serializer.data, status=status.HTTP_201_CREATED)\r\n        except:\r\n            return Response({'error': 'Invalid email address!'}, status=status.HTTP_400_BAD_REQUEST)\r\n\r\n        if serializer.errors['username'] != None:\r\n            return Response({'error': serializer.errors['username']}, status=status.HTTP_400_BAD_REQUEST)\r\n\r\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\r\n\r\n    @action(detail=False, methods=['put'])\r\n    def updateMembership(self, request, user_id):\r\n        try:\r\n            userObject = User.objects.get(id=user_id)\r\n            if (userObject.user_type == 'Member'):\r\n                return Response({'error': 'User is already a member!'},\r\n                                status=status.HTTP_400_BAD_REQUEST)\r\n            elif (userObject.user_type == 'Admin'):\r\n                return Response({'error': 'User is an employee!'},\r\n                                status=status.HTTP_400_BAD_REQUEST)\r\n            else:\r\n                userObject.user_type = 'Member'\r\n                userObject.save()\r\n                serializer = UserSerializer(userObject)\r\n                return Response(serializer.data, status=status.HTTP_200_OK)\r\n        except:\r\n            return Response({'error': 'User does not exist!'}, status=status.HTTP_400_BAD_REQUEST)\r\n\r\n\r\nclass signUpTraining(viewsets.ModelViewSet):\r\n    queryset = Enrollments.objects.all()\r\n    serializer_class = EnrollmentsSerializer\r\n\r\n    @action(detail=False, methods=['post'])\r\n    def signupfortraining(self, request, *args, **kwargs):\r\n        username = request.user.username\r\n        userTrainingObjects = []\r\n        userTrainingObjects = Enrollments.objects.filter(username=request.user.id)\r\n        userTrainingIDs = [i.training_id.training_id for i in userTrainingObjects]\r\n        if int(request.data[\"training_id\"]) in userTrainingIDs:\r\n            return Response({'error': 'User is already registered for this training!'},\r\n                            status=status.HTTP_400_BAD_REQUEST)\r\n\r\n        catch_training = Training.objects.get(pk=request.data[\"training_id\"])\r\n        if catch_training.current_capacity >= catch_training.max_capacity:\r\n            return Response({\r\n                'error': 'Capacity for the training session is full, please reach out to a health club employee for further information'},\r\n                status=status.HTTP_400_BAD_REQUEST)\r\n        catch_training.current_capacity += 1\r\n        catch_training.save()\r\n        request.data[\"username\"] = request.user.id\r\n        serializer = self.get_serializer(data=request.data)\r\n        serializer.is_valid(raise_exception=True)\r\n        self.perform_create(serializer)\r\n        headers = self.get_success_headers(serializer.data)\r\n        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\r\n\r\n    @action(detail=False, methods=['post'])\r\n    def signUpnonmembersfortraining(self, request):\r\n        # Check if the user is an admin\r\n        permission_classes = [IsAdminUser]\r\n\r\n        # Get the username and training_id from the request data\r\n        username = request.data.get('username')\r\n        training_id = request.data.get('training_id')\r\n\r\n        # Check if the user is already enrolled in this training\r\n        getUserObj = User.objects.filter(email=username)\r\n        print(getUserObj)\r\n        username = str(getUserObj.first().id)\r\n        userTrainingObjects = Enrollments.objects.filter(username=username)\r\n        userTrainingIDs = [i.training_id.training_id for i in userTrainingObjects]\r\n        if int(training_id) in userTrainingIDs:\r\n            return Response({'error': 'User is already registered for this training!'},\r\n                            status=status.HTTP_400_BAD_REQUEST)\r\n\r\n        # Check if the training session is at capacity\r\n        catch_training = Training.objects.get(pk=int(training_id))\r\n        if catch_training.current_capacity >= catch_training.max_capacity:\r\n            return Response({\r\n                'error': 'Capacity for the training session is full'},\r\n                status=status.HTTP_400_BAD_REQUEST)\r\n\r\n        # Check if the user's trial membership has expired\r\n        user = User.objects.get(id=username)\r\n        current_time = datetime.now(pytz.utc)\r\n        sub_expiry_date = user.date_joined + timedelta(days=30)\r\n        if (current_time > sub_expiry_date):\r\n            return Response({\r\n                'error': 'User trial membership has expired!'},\r\n                status=status.HTTP_400_BAD_REQUEST)\r\n\r\n        # Check if the training session is scheduled after the user's trial membership expiration\r\n        if catch_training.start_time >= sub_expiry_date:\r\n            return Response({\r\n                'error': 'Training session is scheduled after user trial membership expiration!'},\r\n                status=status.HTTP_400_BAD_REQUEST)\r\n\r\n        catch_training.current_capacity += 1\r\n        catch_training.save()\r\n        request.data[\"username\"] = username\r\n        serializer = self.get_serializer(data=request.data)\r\n        serializer.is_valid(raise_exception=True)\r\n        self.perform_create(serializer)\r\n        headers = self.get_success_headers(serializer.data)\r\n        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\r\n\r\n\r\n##\r\nclass enrollmentStats(viewsets.ModelViewSet):\r\n    @action(detail=False, methods=['get'])\r\n    def getEnrollmentStats(self, request, *args, **kwargs):\r\n        permission_classes = [IsAdminUser]\r\n        start_time_str = request.query_params.get('start_time')\r\n        end_time_str = request.query_params.get('end_time')\r\n        location_id = request.query_params.get('location_id')\r\n\r\n        if not start_time_str or not end_time_str or not location_id:\r\n            return Response({'error': 'start_time, end_time, and location_id are required parameters'})\r\n\r\n        start_time = timezone.datetime.fromisoformat(start_time_str).replace(tzinfo=pytz.utc)\r\n        end_time = timezone.datetime.fromisoformat(end_time_str).replace(tzinfo=pytz.utc)\r\n\r\n        # Query enrollments based on start time range and location_id\r\n        enrollment_counts = Enrollments.objects.filter(\r\n            training_id__start_time__range=(start_time, end_time),\r\n            training_id__location_id__location_id=location_id\r\n        ).values('training_type').annotate(count=Count('training_type'))\r\n\r\n        # Convert the queryset to a list of dictionaries for JSON serialization\r\n        enrollment_counts_list = list(enrollment_counts)\r\n\r\n        return Response(enrollment_counts_list)\r\n\r\n\r\n##\r\n\r\n\r\nclass cancelEnrollment(viewsets.ModelViewSet):\r\n    queryset = Enrollments.objects.all()\r\n    serializer_class = EnrollmentsSerializer\r\n\r\n    # pk_field = 'training_id'\r\n    @action(detail=False, methods=['delete'])\r\n    def destroy(self, request, *args, **kwargs):\r\n        queryset = self.get_queryset()\r\n        userid = request.user.id\r\n        training_id = kwargs['pk']\r\n        obj = get_object_or_404(queryset, username=userid, training_id=training_id)\r\n        training_obj = Training.objects.get(training_id=training_id)\r\n        training_obj.current_capacity -= 1\r\n        training_obj.save()\r\n        obj.delete()\r\n        return Response({'Enrollment deleted!'}, status=status.HTTP_204_NO_CONTENT)\r\n\r\n\r\n\"\"\"This returns all training for a loction with pk \"\"\"\r\n\r\n\r\nclass viewTraining(viewsets.ModelViewSet):\r\n    queryset = Training.objects.all()\r\n    serializer_class = TrainingSerializer\r\n    permission_classes = [AllowAny]\r\n\r\n    @action(detail=False, methods=['get'])\r\n    def viewtrainingdetails(self, request, *args, **kwargs):\r\n        try:\r\n            location_id = kwargs['pk']\r\n            if kwargs['pk']:\r\n                location_id = kwargs['pk']\r\n                training = Training.objects.filter(location_id=location_id)\r\n                serializer = TrainingSerializer(training, many=True)\r\n                return Response(serializer.data)\r\n        except:\r\n            training = Training.objects.filter()\r\n            serializer = TrainingSerializer(training, many=True)\r\n            return Response(serializer.data)\r\n\r\n\r\n# This API is used for retrieving Member specific enrollment details\r\nclass ViewMemberTrainingEnrollment(viewsets.ModelViewSet):\r\n    serializer_class = TrainingSerializer\r\n\r\n    @action(detail=False, methods=['get'])\r\n    def list(self, request, user_id=None):\r\n        enrollments = Enrollments.objects.filter(username__id=request.user.id).select_related('training_id')\r\n        training_ids = [enrollment.training_id_id for enrollment in enrollments]\r\n        trainings = Training.objects.filter(training_id__in=training_ids).select_related('location_id')\r\n\r\n        memberdetails = []\r\n        for training in trainings:\r\n            location_name = training.location_id.location_name\r\n            location_address = training.location_id.location_address\r\n            start_time = training.start_time.astimezone(pytz.timezone('America/Los_Angeles')).strftime(\r\n                \"%Y-%m-%d %I:%M %p\")\r\n            end_time = training.end_time.astimezone(pytz.timezone('America/Los_Angeles')).strftime(\"%Y-%m-%d %I:%M %p\")\r\n            memberdetails.append({\r\n                'Training_id': training.training_id,\r\n                'Instructor_name': training.instructor_name,\r\n                'Class_Type': training.training_type,\r\n                'Start_time': start_time,\r\n                'End_time': end_time,\r\n                'location_name': location_name,\r\n                'location_address': location_address\r\n            })\r\n\r\n        return Response(memberdetails)\r\n\r\n\r\nclass TokenRevokeSet(viewsets.ModelViewSet):\r\n    @action(detail=False, methods=['delete'])\r\n    def revoke(self, request):\r\n        request.auth.delete()\r\n        return Response({'Logged out successfully!'}, status=status.HTTP_200_OK)\r\n\r\n\r\n# class CustomAuthToken(ObtainAuthToken):\r\n#     queryset = User.objects.all()\r\n#\r\n#     def post(self, request, *args, **kwargs):\r\n#         serializer = self.serializer_class(data=request.data,\r\n#                                            context={'request': request})\r\n#         serializer.is_valid(raise_exception=True)\r\n#         user = serializer.validated_data['user']\r\n#         nUser = User.objects.filter(username=user.username).get()\r\n#         if nUser.isNonMember():\r\n#             return Response({\"Non-members can't login\"}, status=status.HTTP_403_FORBIDDEN)\r\n#         token, created = Token.objects.get_or_create(user=user)\r\n#         return Response({\r\n#             'token': token.key,\r\n#             'first_name': user.first_name,\r\n#             'user_type': nUser.user_type,\r\n#             'user_id': nUser.id,\r\n#         })\r\n\r\n\r\nclass CustomAuthToken(ObtainAuthToken):\r\n    queryset = User.objects.all()\r\n\r\n    def post(self, request, *args, **kwargs):\r\n        serializer = self.serializer_class(data=request.data,\r\n                                           context={'request': request})\r\n        serializer.is_valid(raise_exception=True)\r\n        user = serializer.validated_data['user']\r\n\r\n        # Фильтруем пользователей по имени и получаем первого пользователя, если он существует\r\n        nUser = User.objects.filter(username=user.username).first()\r\n\r\n        if nUser and nUser.isNonMember():\r\n            return Response({\"Non-members can't login\"}, status=status.HTTP_403_FORBIDDEN)\r\n\r\n        # Создаем или получаем токен для пользователя\r\n        token, created = Token.objects.get_or_create(user=user)\r\n\r\n        # Возвращаем токен и дополнительные данные\r\n        return Response({\r\n            'token': token.key,\r\n            'first_name': user.first_name,\r\n            'user_type': nUser.user_type if nUser else None,\r\n            'user_id': nUser.id if nUser else None,\r\n        })\r\n\r\n\r\nclass LocationList(viewsets.ModelViewSet):\r\n    queryset = Location.objects.all()\r\n    serializer_class = LocationSerializer\r\n    permission_classes = [AllowAny]\r\n\r\n    @action(detail=False, methods=['get'])\r\n    def locations(self, request):\r\n        locations = self.get_queryset()\r\n        serializer = self.get_serializer(locations, many=True)\r\n        return Response(serializer.data)\r\n\r\n\r\nclass LocationDetails(viewsets.ModelViewSet):\r\n    queryset = Location.objects.all()\r\n    serializer_class = LocationSerializer\r\n    permission_classes = [AllowAny]\r\n\r\n    @action(detail=False, methods=['get'])\r\n    def location_details(self, request):\r\n        location_details = self.filter_queryset(self.get_queryset())\r\n        location_details = location_details.values('location_name', 'location_address')\r\n        serializer = self.get_serializer(location_details, many=True)\r\n        return Response(serializer.data)\r\n\r\n\r\nclass ActivityList(viewsets.ModelViewSet):\r\n    queryset = Activity.objects.all()\r\n    serializer_class = ActivitySerializer\r\n    permission_classes = [AllowAny]\r\n\r\n    @action(detail=False, methods=['get'])\r\n    def activities(self, request):\r\n        activities = self.get_queryset()\r\n        serializer = self.get_serializer(activities, many=True)\r\n        return Response(serializer.data)\r\n\r\n\r\nclass ActivityDetails(viewsets.ModelViewSet):\r\n    queryset = Activity.objects.all()\r\n    serializer_class = ActivitySerializer\r\n    permission_classes = [AllowAny]\r\n\r\n    @action(detail=False, methods=['get'])\r\n    def activity_details(self, request):\r\n        activity_details = self.filter_queryset(self.get_queryset())\r\n        activity_details = activity_details.values('id', 'type')\r\n        serializer = self.get_serializer(activity_details, many=True)\r\n        return Response(serializer.data)\r\n\r\n\r\nclass ActivityLogView(viewsets.ModelViewSet):\r\n    permission_classes = [IsAuthenticated]  # Or other permissions you want to set\r\n\r\n    @action(detail=False, methods=['post'])\r\n    def create(self, request):\r\n        serializer = ActivityLogSerializer(data=request.data)\r\n        if serializer.is_valid():\r\n            serializer.save()\r\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\r\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\r\n\r\n\r\nclass UserViewSet(viewsets.ModelViewSet):\r\n    queryset = User.objects.all()\r\n    serializer_class = UserSerializer\r\n    permission_classes = [IsAuthenticated]\r\n\r\n    def get(self, request, email):\r\n        try:\r\n            userObject = User.objects.get(username=email)\r\n            response_data = {}\r\n            response_data['id'] = userObject.id\r\n            response_data['first_name'] = userObject.first_name\r\n            response_data['last_name'] = userObject.last_name\r\n            return JsonResponse(response_data)\r\n        except:\r\n            return Response({'error': 'User does not exist!'}, status=status.HTTP_400_BAD_REQUEST)\r\n\r\n\r\nclass ActivityLogSet(viewsets.ModelViewSet):\r\n    queryset = ActivityLog.objects.all()\r\n    serializer_class = ActivityLogSerializer\r\n    permission_classes = [IsAuthenticated]\r\n\r\n    @action(detail=False, methods=['get'])\r\n    def getActivityLog(self, request):\r\n        options = request.query_params.get('options', '')\r\n        try:\r\n            if options == '90_days':\r\n                today = timezone.now()\r\n                past_period = today - timedelta(days=90)\r\n                logs = ActivityLog.objects.filter(username=request.user.id, timestamp__gte=past_period)\r\n            elif options == 'week':\r\n                today = timezone.now()\r\n                past_period = today - timedelta(weeks=1)\r\n                logs = ActivityLog.objects.filter(username=request.user.id, timestamp__gte=past_period)\r\n            elif options == 'month':\r\n                today = timezone.now()\r\n                past_period = today - timedelta(weeks=4)\r\n                logs = ActivityLog.objects.filter(username=request.user.id, timestamp__gte=past_period)\r\n            else:\r\n                return Response({'error': 'Invalid option'}, status=status.HTTP_400_BAD_REQUEST)\r\n\r\n        except:\r\n            return Response({'error': 'Invalid request'}, status=status.HTTP_400_BAD_REQUEST)\r\n\r\n        data = []\r\n        if (logs == None):\r\n            return Response({'No logs found'}, status=status.HTTP_200_OK)\r\n        for log in logs:\r\n            data.append({\r\n                'activity': log.activity.type,\r\n                'duration': log.duration,\r\n                'calories': log.calories,\r\n                'timestamp': log.timestamp,\r\n                'distance': log.distance\r\n\r\n            })\r\n\r\n        return JsonResponse({'logs': data})\r\n\r\n\r\nclass EquipmentViewSet(viewsets.ViewSet):\r\n    queryset = ActivityLog.objects.all()\r\n    serializer_class = ActivityLogSerializer\r\n    permission_classes = [IsAdminUser]\r\n\r\n    @action(detail=True, methods=['get'])\r\n    def equipmenttypes(self, request, pk=None):\r\n        location_id = pk\r\n        user_logs = User_log.objects.filter(location_id=location_id)\r\n        activity_logs = ActivityLog.objects.filter(username__in=user_logs.values_list('username', flat=True))\r\n        # activity_logs = ActivityLog.objects.filter(username__user_log__location_id=location_id)\r\n        activity_counts = activity_logs.values('activity', 'activity__type').annotate(count=Count('activity')).order_by(\r\n            '-count')\r\n        activity_types = [{'type': count['activity__type'], 'count': count['count']} for count in activity_counts]\r\n        return Response(activity_types)\r\n\r\n\r\nclass VisitorCountByHourViewSet(viewsets.ModelViewSet):\r\n    queryset = User_log.objects.all()\r\n    serializer_class = UserLogSerializer\r\n    permission_classes = [IsAdminUser]\r\n\r\n    def list(self, request, location_id):\r\n        # Get the query parameters from the request\r\n        time_period = self.request.query_params.get('time_period')\r\n        options = self.request.query_params.get('options')\r\n        selected_date = self.request.query_params.get('selected_date')\r\n        if (location_id == 'none'):\r\n            return Response({\"error\": \"Please select a location\"},\r\n                            status=status.HTTP_400_BAD_REQUEST)\r\n            # Filter user logs based on location\r\n        user_logs = User_log.objects.filter(location_id=location_id)\r\n        if time_period == 'weekday' or time_period == 'weekend':\r\n            if not options:\r\n                return Response({\"error\": \"Please select a time range\"},\r\n                                status=status.HTTP_400_BAD_REQUEST)\r\n            elif options == '90_days':\r\n                today = timezone.now()\r\n                past_period = today - timedelta(days=90)\r\n                user_logs = user_logs.filter(checkin_time__gte=past_period)\r\n            elif options == 'week':\r\n                today = timezone.now()\r\n                past_period = today - timedelta(weeks=1)\r\n                user_logs = user_logs.filter(checkin_time__gte=past_period)\r\n            elif options == 'month':\r\n                today = timezone.now()\r\n                past_period = today - timedelta(weeks=4)\r\n                user_logs = user_logs.filter(checkin_time__gte=past_period)\r\n\r\n        # Filter user logs based on time period\r\n        if time_period == 'weekday':\r\n            user_logs = user_logs.filter(checkin_time__week_day__range=(2, 6))  # Monday to Friday\r\n        elif time_period == 'weekend':\r\n            user_logs = user_logs.filter(checkin_time__week_day__in=[1, 7])\r\n        elif time_period == 'day':\r\n            if not selected_date:\r\n                return Response({\"error\": \"Please provide a selected_date for 'day' time period\"},\r\n                                status=status.HTTP_400_BAD_REQUEST)\r\n\r\n            # Convert selected_date string to datetime object\r\n            try:\r\n                selected_date = datetime.strptime(selected_date, '%Y-%m-%d').date()\r\n            except ValueError:\r\n                return Response({\"error\": \"Invalid date format for selected_date\"},\r\n                                status=status.HTTP_400_BAD_REQUEST)\r\n\r\n            user_logs = user_logs.filter(checkin_time__date=selected_date)\r\n        # Count the number of visitors by the hour\r\n        visitor_counts = user_logs.values('checkin_time__hour').annotate(visitor_count=Count('*')).order_by(\r\n            'checkin_time__hour')\r\n        results = []\r\n        for count in visitor_counts:\r\n            hour = count['checkin_time__hour']\r\n            hour_12 = datetime.strptime(str(hour), '%H').strftime('%I %p')\r\n            result = {\r\n                'hour': hour_12,\r\n                'visitor_count': count['visitor_count']\r\n            }\r\n            results.append(result)\r\n        return Response(results, status=status.HTTP_200_OK)\r\n\r\n\r\nclass HoursCountByLocationViewSet(viewsets.ModelViewSet):\r\n    queryset = User_log.objects.all()\r\n    serializer_class = UserLogSerializer\r\n    permission_classes = [IsAdminUser]\r\n\r\n    def list(self, request, location_id):\r\n        # Retrieve data from User_log model\r\n        if (location_id == 'none'):\r\n            return Response({\"error\": \"Please select a location\"},\r\n                            status=status.HTTP_400_BAD_REQUEST)\r\n        user_logs = User_log.objects.filter(location_id=location_id)\r\n        data = []\r\n        for user_log in user_logs:\r\n            user_id = user_log.username\r\n            checkin_time = user_log.checkin_time\r\n            checkout_time = user_log.checkout_time\r\n            location_id = user_log.location_id\r\n            if checkout_time:\r\n                data.append((checkin_time, checkout_time))\r\n        # Calculate hours\r\n        daily_hours = defaultdict(int)\r\n        weekly_hours = defaultdict(int)\r\n        monthly_hours = defaultdict(int)\r\n        results = []\r\n        for check_in, check_out in data:\r\n            check_in = datetime.fromisoformat(str(check_in))\r\n            check_out = datetime.fromisoformat(str(check_out))\r\n\r\n            duration = (check_out - check_in).seconds / 3600\r\n            # Update daily_hours\r\n            day_key = str(check_in.date().isoformat())\r\n            daily_hours[day_key] += duration\r\n\r\n            # Update weekly_hours\r\n            week_key = str(check_in.year) + '_' + str(check_in.isocalendar()[1])\r\n            weekly_hours[week_key] += duration\r\n\r\n            # Update monthly_hours\r\n            month_key = str(check_in.year) + '_' + str(check_in.month)\r\n            monthly_hours[month_key] += duration\r\n        response_data = {\r\n            \"daily_hours\": {str(key): value for key, value in daily_hours.items()},\r\n            \"weekly_hours\": {str(key): value for key, value in weekly_hours.items()},\r\n            \"monthly_hours\": {str(key): value for key, value in monthly_hours.items()},\r\n        }\r\n        return Response(response_data, status=status.HTTP_200_OK)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/api_csms/csms/views.py b/api_csms/csms/views.py
--- a/api_csms/csms/views.py	(revision d27eb2596bde94aa29393d0215b47551842278af)
+++ b/api_csms/csms/views.py	(date 1712671126754)
@@ -330,24 +330,6 @@
         return Response({'Logged out successfully!'}, status=status.HTTP_200_OK)
 
 
-# class CustomAuthToken(ObtainAuthToken):
-#     queryset = User.objects.all()
-#
-#     def post(self, request, *args, **kwargs):
-#         serializer = self.serializer_class(data=request.data,
-#                                            context={'request': request})
-#         serializer.is_valid(raise_exception=True)
-#         user = serializer.validated_data['user']
-#         nUser = User.objects.filter(username=user.username).get()
-#         if nUser.isNonMember():
-#             return Response({"Non-members can't login"}, status=status.HTTP_403_FORBIDDEN)
-#         token, created = Token.objects.get_or_create(user=user)
-#         return Response({
-#             'token': token.key,
-#             'first_name': user.first_name,
-#             'user_type': nUser.user_type,
-#             'user_id': nUser.id,
-#         })
 
 
 class CustomAuthToken(ObtainAuthToken):
